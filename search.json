[
  {
    "objectID": "embedded/concurrency-goroutines.html",
    "href": "embedded/concurrency-goroutines.html",
    "title": "Concurrency with Goroutines",
    "section": "",
    "text": "Let us modify the simple blink program from our earlier tutorial to run multiple tasks simultaneously. This is what we call concurrency.\nGo has a number of primitives to help make programmers’ lives easier when they create concurrent programs. In this tutorial, we will look at one of them, namely Goroutines.",
    "crumbs": [
      "Embedded Systems",
      "Concurrency with Goroutines"
    ]
  },
  {
    "objectID": "embedded/concurrency-goroutines.html#the-program",
    "href": "embedded/concurrency-goroutines.html#the-program",
    "title": "Concurrency with Goroutines",
    "section": "The Program",
    "text": "The Program\nThe aim of our program is to do the following two things at once:\n\nBlink the onboard LED twice a second.\nPrint the phrase “hello concurrently” to the serial (UART) port.\n\nWe modify the blink.go program from the earlier tutorial to add:\n\nA function (named printHello) that prints “hello concurrently” in an infinite loop.\nA goroutine that spawns this function so that it runs concurrent to the main thread that is blinking the LED.\n\npackage main\n\nimport (\n    \"machine\"\n    \"time\"\n)\n\nfunc main() {\n    led := machine.LED\n    led.Configure(machine.PinConfig{\n            Mode: machine.PinOutput,\n    })\n        \n    go printHello()\n    \n    for {\n        led.High()\n        time.Sleep(500 * time.Millisecond)\n        led.Low()\n        time.Sleep(500 * time.Millisecond)\n    }\n}\n\nfunc printHello() {\n    for {\n        println(\"hello concurrently\")\n        time.Sleep(time.Second)\n    }\n}",
    "crumbs": [
      "Embedded Systems",
      "Concurrency with Goroutines"
    ]
  },
  {
    "objectID": "embedded/concurrency-goroutines.html#testing-the-program",
    "href": "embedded/concurrency-goroutines.html#testing-the-program",
    "title": "Concurrency with Goroutines",
    "section": "Testing the Program",
    "text": "Testing the Program\nEnsure that your serial console is set up as described in my earlier tutorial on setting up the Pico for serial debugging.\nFlash the program to your pico:\n% tinygo flash -target=pico concurrentblink.go\nYou should see the onboard LED blinking, while the phrase “hello concurrently” is printed every second in the serial monitor.",
    "crumbs": [
      "Embedded Systems",
      "Concurrency with Goroutines"
    ]
  },
  {
    "objectID": "embedded/concurrency-goroutines.html#references",
    "href": "embedded/concurrency-goroutines.html#references",
    "title": "Concurrency with Goroutines",
    "section": "References",
    "text": "References\n\nRob Pike’s presentation on “Concurrency is not parallelism”.",
    "crumbs": [
      "Embedded Systems",
      "Concurrency with Goroutines"
    ]
  },
  {
    "objectID": "embedded/blinking-an-led.html#the-program",
    "href": "embedded/blinking-an-led.html#the-program",
    "title": "Blinking an LED with TinyGo",
    "section": "The Program",
    "text": "The Program\nThe program itself is simple - about 15 lines of code.\n// blink.go\n\npackage main\n\nimport (\n        \"machine\"\n        \"time\"\n)\n\nfunc main() {\n        led := machine.LED\n        led.Configure(machine.PinConfig{\n        Mode: machine.PinOutput,\n        })\n        \n        for {\n            led.High()\n            time.Sleep(500 * time.Millisecond)\n            led.Low()\n            time.Sleep(500 * time.Millisecond)\n        }\n}",
    "crumbs": [
      "Embedded Systems",
      "Blinking an LED with TinyGo"
    ]
  },
  {
    "objectID": "embedded/blinking-an-led.html#basic-steps-to-interact-with-gpio",
    "href": "embedded/blinking-an-led.html#basic-steps-to-interact-with-gpio",
    "title": "Blinking an LED with TinyGo",
    "section": "Basic Steps to Interact with GPIO",
    "text": "Basic Steps to Interact with GPIO\nThe basic steps for interacting with a General Purpose Input-Output (GPIO) pin on the Pico are the same:\n\nImport the machine package.\nCreate a variable that is an instance of the GPIO pin.\nConfigure the instance.\nLoop while doing something with the pin.\n\nLet us examine each of these steps in detail.\n\nImport the machine Package\nimport (\n        \"machine\"\n        ... // other imports\n)\nThe machine package provides an abstraction in Go to the underlying capabilities of the microcontroller target. It also defines some constants that make it easier when referring to the facilities of the microcontroller in Go. As an example, consider the machine.LED constant, which represents the onboard LED on the Pico.\n\n\nCreate an Instance of the Pin\nled := machine.LED\nCreating the variable and initializing it to an instance of Pin allows us to access the variable in other parts of the program.\nNote that the pin is not configured yet. That needs to be done in the next step.\n\n\nConfigure the Pin Instance\nled.Configure(machine.PinConfig{\n        Mode: machine.PinOutput,\n})\nThe Configure function takes an instance of a type called PinConfig as its input. The PinConfig type is defined as below:\ntype PinConfig struct {\n        Mode PinMode\n}\nThe following Modes are accepted:\nconst (\n        PinOutput PinMode = iota\n        PinInput\n        PinInputPulldown\n        PinInputPullup\n        PinAnalog\n        PinUART\n        PinPWM\n        PinI2C\n        PinSPI\n)\nSince we want the LED to blink, but are not concerned about its input, we configure the pin as a PinOutput.\n\n\nLoop\nOnce the GPIO pins are initialized and configured, we loop while performing a set of tasks. This is typical of any microcontroller (or embedded) application.\nIn the case of this trivial “blink” program, we turn the LED on and off periodically inside the loop. For the purposes of this program, we use a time of 500 milliseconds between turning the LED on, and turning it off.\nfor {\n    led.High()\n    time.Sleep(500 * time.Millisecond)\n    led.Low()\n    time.Sleep(500 * time.Millisecond)\n}\nOutputting a High to the pin switches on the LED, while a Low turns it off. The time.sleep merely pauses the program so that the pin isn’t toggled so frequently that the LED never appears to turn off.",
    "crumbs": [
      "Embedded Systems",
      "Blinking an LED with TinyGo"
    ]
  },
  {
    "objectID": "embedded/blinking-an-led.html#summary",
    "href": "embedded/blinking-an-led.html#summary",
    "title": "Blinking an LED with TinyGo",
    "section": "Summary",
    "text": "Summary\nIn this tutorial, we learnt to:\n\nInitialize and configure a single GPIO pin using TinyGo.\nOutput binary high or low values to the pin.\nRun our program endlessly.",
    "crumbs": [
      "Embedded Systems",
      "Blinking an LED with TinyGo"
    ]
  },
  {
    "objectID": "embedded/blinking-an-led.html#references",
    "href": "embedded/blinking-an-led.html#references",
    "title": "Blinking an LED with TinyGo",
    "section": "References",
    "text": "References\n\nGitHub\nmachine package reference for Pico",
    "crumbs": [
      "Embedded Systems",
      "Blinking an LED with TinyGo"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Recent Articles",
    "section": "",
    "text": "Welcome to pragmatik.tech. This is a site dedicated to technology, specifically the following:\n\nEmbedded programming in TinyGo and Micropython, with an emphasis on the Raspberry Pi Pico.\nGenerative AI programming in Java (using LangChain4J) and Python.\nMachine learning (coming soon).\n\n\nRecent Articles\n\n\n\n\n\n\n\n\n\n\nConcurrency with Goroutines\n\n\nDoing multiple things at once.\n\n\n\nEmbedded Systems\n\n\nTinyGo\n\n\n\n\nCharath Ranganathan\n\n\nJul 10, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBlinking an LED with TinyGo\n\n\nYour first program.\n\n\n\nEmbedded Systems\n\n\nTinyGo\n\n\n\n\nCharath Ranganathan\n\n\nJul 4, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSet up your Pico with TinyGo and VScode\n\n\nLet the fun begin!\n\n\n\nEmbedded Systems\n\n\nTinyGo\n\n\n\n\nCharath Ranganathan\n\n\nJul 1, 2022\n\n\n\n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Charath Ranganathan is the CTO at Crowdbotics, where they are revolutionizing the software development lifecycle (SDLC) through their AI-based code-to-spec system.\nCharath has been an avid coder for over 4 decades, having started with BASIC on a Casio Handheld computer and then on a Sinclair ZX Spectrum in the early 1980s. He is a polyglot programmer with experience in a wide range of programming languages from COBOL and FORTRAN, through Java and Python, to Go.\nCharath is also very interested in embedded systems programming, especially in TinyGo and Micropython. You can view his tutorials on YouTube.\nWhen he is not working or coding, Charath can be found at his local airport, where he is an FAA-certified flight instructor with the Caltech/JPL Flying Club.",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "about.html#experience-partial",
    "href": "about.html#experience-partial",
    "title": "About",
    "section": "Experience (partial)",
    "text": "Experience (partial)\nCrowdboticsCTODecember 2018 - present\nPlaytika Santa MonicaVP - EngineeringApril 2012 - April 2016\nSun Microsystems, Inc.Multiple engineering management rolesSeptember 2002 - March 2009\nSIP TechnologiesCo-founderJuly 1996 - September 2002",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "About",
    "section": "Education",
    "text": "Education\nTexas A&M University, College Station, TX M.S. in Electrical Engineering  1990 - 1993\nCollege of Engineering, Anna University, Chennai, India B.E. in Electrical and Electronics Engineering 1986 - 1990",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "embedded/setting-up-tinygo.html",
    "href": "embedded/setting-up-tinygo.html",
    "title": "Set up your Pico with TinyGo and VScode",
    "section": "",
    "text": "The TinyGo web site has a detailed installation guide for various operating systems. So, the steps below are just for your quick reference. When in doubt, refer to the TinyGo web site.",
    "crumbs": [
      "Embedded Systems",
      "Set up your Pico with TinyGo and VScode"
    ]
  },
  {
    "objectID": "embedded/setting-up-tinygo.html#prerequisites",
    "href": "embedded/setting-up-tinygo.html#prerequisites",
    "title": "Set up your Pico with TinyGo and VScode",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nGo version 1.20 or greater.\nVisual Studio Code: I currently run VSCode 1.98.2.",
    "crumbs": [
      "Embedded Systems",
      "Set up your Pico with TinyGo and VScode"
    ]
  },
  {
    "objectID": "embedded/setting-up-tinygo.html#install-tinygo-using-homebrew",
    "href": "embedded/setting-up-tinygo.html#install-tinygo-using-homebrew",
    "title": "Set up your Pico with TinyGo and VScode",
    "section": "Install TinyGo using Homebrew",
    "text": "Install TinyGo using Homebrew\nRun the following commands:\n% brew tap tinygo-org/tools\n% brew install tinygo\nVerify that the installation was successful by running this command, which should give you the output that is shown below it.\n% tinygo version\ntinygo version 0.25.0 darwin/amd64 (using go version go1.18.5 and LLVM version 14.0.0)",
    "crumbs": [
      "Embedded Systems",
      "Set up your Pico with TinyGo and VScode"
    ]
  },
  {
    "objectID": "embedded/setting-up-tinygo.html#install-the-tinygo-vscode-extension",
    "href": "embedded/setting-up-tinygo.html#install-the-tinygo-vscode-extension",
    "title": "Set up your Pico with TinyGo and VScode",
    "section": "Install the TinyGo VSCode Extension",
    "text": "Install the TinyGo VSCode Extension\nInside VSCode, search for the TinyGo VSCode extension and install it.\n\nThis extension requires the VSCode Go extension to be installed. If not already installed, the Go extension is installed as a dependency by the TinyGo extension’s installer.\n\nTesting the VSCode Installation\n\nPut the Pico into Bootsel mode by holding down the BOOTSEL button on the Pico while plugging in the USB cable.\nRelease the BOOTSEL button. You should now see a drive named RPI-RP2 on your Desktop.\nGo to the VSCode Command Window (Cmd-Shift-P on Mac, Ctrl-Shift-P on Windows) and run the TinyGo target command. Select pico for the board. The command will run and create a .vscode/settings.json file in your workspace home directory. This provides the appropriate type hints for Intellisense to work correctly.\nStart a new Go program in VSCode. Let’s name it blinky.go.\n\n// blinky.go\n\npackage main\n\nimport (\n    \"machine\"\n    \"time\"\n)\n\nfunc main() {\n    led := machine.LED\n    led.Configure(machine.PinConfig{\n        Mode: machine.PinOutput,\n    })\n\n    for {\n        led.High()\n        time.Sleep(500 * time.Millisecond)\n        led.Low()\n        time.Sleep(500 * time.Millisecond)\n    }\n}\n\nFlash the program to your Pico using the tinygo flash command:\n\n   % tinygo flash -target=pico blinky.go\nYou should now see the onboard LED blink twice a second, i.e. at 2 Hz.\nYou have now set up TinyGo on your computer, as well as the TinyGo VSCode extension. The next steps are optional.",
    "crumbs": [
      "Embedded Systems",
      "Set up your Pico with TinyGo and VScode"
    ]
  },
  {
    "objectID": "embedded/setting-up-tinygo.html#optional-install-a-reset-button",
    "href": "embedded/setting-up-tinygo.html#optional-install-a-reset-button",
    "title": "Set up your Pico with TinyGo and VScode",
    "section": "(Optional) Install a Reset Button",
    "text": "(Optional) Install a Reset Button\nI highly recommend this step since it makes the process of flashing new programs to your Pico significantly less tedious than unplugging and replugging the USB cable into the Pico while holding down the BOOTSEL button.\nDetailed instructions are available on the Raspberry Pi web site, but a summary is below.\nConnect a push button between the RUN pin (pin 30) on your Pico and ground. Refer to the image below from the Raspberry Pi web site.\n\nInstalling the reset button for the Pico\nTo load a new program, follow these steps:\n\nHold down the pushbutton and the BOOTSEL button.\nRelease the pushbutton.\nRelease the BOOTSEL button.\n\nYou’ll see the RPI-RP2 folder on your computer indicating your Pico is ready to be flashed with a new program.",
    "crumbs": [
      "Embedded Systems",
      "Set up your Pico with TinyGo and VScode"
    ]
  },
  {
    "objectID": "embedded/setting-up-tinygo.html#optional-enable-serial-debugging",
    "href": "embedded/setting-up-tinygo.html#optional-enable-serial-debugging",
    "title": "Set up your Pico with TinyGo and VScode",
    "section": "(Optional) Enable Serial Debugging",
    "text": "(Optional) Enable Serial Debugging\nIn most microcontroller projects, it is easy (and common) to use the serial port for debugging. If you use MicroPython or CircuitPython, the serial messages are sent via the USB connection to your computer.\nUnfortunately, the RP2040 port of TinyGo does not support the printing of serial messages over the USB port. Consequently, you will have to use the UART on the Pico to send debugging messages.\nAs of TinyGo 0.25.0, USB is supported for debugging. So, this section is moot, but I have left it here in case someone wants to set up a UART connection to their computer.\n\nInstall a UART-to-USB Cable\nSince the UART cannot talk directly to USB, you will need a USB-to-Serial cable to convert the UART output to USB-compatible signals.\nThankfully, the fine folks at Adafruit have one such cable.\nPurchase one of these cables, and follow the instructions to install the drivers required for your OS. Then, plug in the individual leads of the cable into the appropriate UART ports of your Pico, and the USB connector into a USB port on your computer.\nIf you get the same cable that I did, the connections are as follows:\n\nBlack: GND\nWhite: UART0 TX (pin 1 - GP0 - on the Pico)\nGreen: UART0 RX (pin 2 - GP1 - on the Pico)\n\n\n\nInstall the Serial Monitor VSCode Extension\nSearch for, and install the Serial Monitor extension for VSCode.\n\nOnce the extension is installed, you’ll see a Serial Monitor tab in the terminal pane in VSCode. Click on that tab and configure the settings as shown in the image:\n\n\n\nVS Code Serial Monitor Settings\n\n\nYou can use the following program to test that your serial connection is successful.\n// serial.go\n\npackage main\n\nimport \"time\"\n\nfunc main() {\n    print(\"starting\")   // the command starts with lowercase \"p\"\n    print(\"program\\n\")  // the command starts with lowercase \"p\"\n\n    for {\n      println(\"hello, world\")   // the command starts with lowercase \"p\"\n      time.Sleep(time.Second)\n    }\n}\nOn the Serial Monitor, ensure you have the correct port selected, and press Start Monitoring.\nPut your Pico into BOOTSEL mode, and flash your program to the Pico.\n% tinygo flash -target=pico serial.go\n\nYou should see the text startingprogram printed out to the serial monitor followed by hello, world, every second. Here is a sample.\n---- Opened the serial port &#x2F;dev&#x2F;tty.usbserial-0001 ----\nstartingprogram\nhello, world\nhello, world\nhello, world\nhello, world\n---- Closed the serial port &#x2F;dev&#x2F;tty.usbserial-0001 ----\n\nPress Stop Monitoring on the Serial Monitor to stop monitoring the serial input.\nYou have now successfully set up serial debugging between your computer and the Pico for TinyGo.\nWhile the extension is great since it’s well integrated with VSCode, the font choice - which is as yet unchangeable - is terrible. Apparently, this issue has been fixed and will release with the next release of this extension, whenever that is.\nGrab a coffee or your drink of choice! You have earned it!",
    "crumbs": [
      "Embedded Systems",
      "Set up your Pico with TinyGo and VScode"
    ]
  }
]